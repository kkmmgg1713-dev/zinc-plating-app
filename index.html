<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÏïÑÏó∞ÎèÑÍ∏àÎëêÍªò Ï∏°Ï†ï</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
            padding: 10px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 15px 10px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        header h1 {
            font-size: 1.3rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .material-section {
            margin-bottom: 10px;
        }

        .material-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .material-header-title {
            font-size: 0.9rem;
            color: #aaa;
        }

        .material-selector {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 10px 5px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            margin-bottom: 8px;
        }

        .material-btn-wrapper {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }

        .material-btn {
            flex-shrink: 0;
            padding: 10px 18px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .material-btn:hover {
            background: rgba(233, 30, 99, 0.3);
        }

        .material-btn.active {
            background: linear-gradient(135deg, #e91e63, #9c27b0);
            border-color: #fff;
        }

        .edit-icon {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .edit-icon:hover {
            background: rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }

        .add-material-btn {
            flex-shrink: 0;
            padding: 10px 15px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: transparent;
            color: #aaa;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .add-material-btn:hover {
            border-color: #e91e63;
            color: #e91e63;
        }

        .sample-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            overflow-x: auto;
            padding: 10px 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .sample-btn {
            flex-shrink: 0;
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .sample-btn:hover {
            background: rgba(0, 212, 255, 0.3);
        }

        .sample-btn.active {
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
            border-color: #fff;
            transform: scale(1.05);
        }

        .sample-btn.completed {
            background: linear-gradient(135deg, #00c853, #00e676);
        }

        .measurement-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 15px;
        }

        .current-sample-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .current-sample-header h2 {
            font-size: 1.2rem;
            color: #00d4ff;
        }

        .progress-indicator {
            font-size: 0.85rem;
            color: #aaa;
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }

        .data-input-wrapper {
            position: relative;
        }

        .data-input-wrapper label {
            position: absolute;
            top: 2px;
            left: 8px;
            font-size: 0.65rem;
            color: #888;
        }

        .data-input {
            width: 100%;
            height: 55px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 1rem;
            text-align: center;
            padding-top: 12px;
            transition: all 0.3s ease;
        }

        .data-input:focus {
            outline: none;
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .data-input.filled {
            border-color: #00c853;
            background: rgba(0, 200, 83, 0.1);
        }

        .data-input.current {
            border-color: #ff9800;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 5px rgba(255, 152, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(255, 152, 0, 0.8);
            }
        }

        .results-section {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(123, 44, 191, 0.2));
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .results-title {
            text-align: center;
            font-size: 1rem;
            margin-bottom: 12px;
            color: #00d4ff;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .result-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .result-box.min {
            border-left: 4px solid #ff5722;
        }

        .result-box.avg {
            border-left: 4px solid #4caf50;
        }

        .result-label {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .result-value {
            font-size: 1.8rem;
            font-weight: 700;
        }

        .result-box.min .result-value {
            color: #ff5722;
        }

        .result-box.avg .result-value {
            color: #4caf50;
        }

        .result-unit {
            font-size: 0.75rem;
            color: #888;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .action-btn.clear {
            background: linear-gradient(135deg, #ff5722, #ff9800);
            color: #fff;
        }

        .action-btn.next {
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
            color: #fff;
        }

        .action-btn:active {
            transform: scale(0.95);
        }

        .summary-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 15px;
        }

        .summary-title {
            text-align: center;
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #00d4ff;
        }

        .summary-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .summary-table th,
        .summary-table td {
            padding: 10px 5px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .summary-table th {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
        }

        .summary-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .export-btn {
            width: 100%;
            padding: 15px;
            margin-top: 15px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #9c27b0, #e91e63);
            color: #fff;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:active {
            transform: scale(0.98);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 3px;
        }

        /* Voice Modal Styles */
        .voice-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .voice-visualization {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #7b2cbf);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
            animation: breathe 2s infinite ease-in-out;
            font-size: 3rem;
        }

        @keyframes breathe {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
            }

            50% {
                transform: scale(1.1);
                box-shadow: 0 0 50px rgba(123, 44, 191, 0.8);
            }
        }

        .voice-status-text {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .voice-result-text {
            color: #00d4ff;
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 40px;
            min-height: 40px;
        }

        .close-voice-btn {
            padding: 12px 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: #fff;
            border-radius: 30px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .voice-btn {
            background: linear-gradient(135deg, #673ab7, #3f51b5);
            color: #fff;
            width: 100%;
            margin-bottom: 10px;
        }

        /* Manual Modal Styles */
        .manual-btn {
            position: absolute;
            top: 60px;
            right: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s;
            z-index: 10;
        }

        .manual-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .manual-modal-content {
            background: #1a1a2e;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow-y: auto;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .manual-title {
            color: #00d4ff;
            font-size: 1.3rem;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .manual-section {
            margin-bottom: 20px;
        }

        .manual-section h4 {
            color: #e91e63;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .manual-list {
            list-style: none;
            padding-left: 5px;
        }

        .manual-list li {
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: #ddd;
            position: relative;
            padding-left: 15px;
            line-height: 1.6;
            word-break: keep-all;
            /* Keeps Korean words together */
        }

        .manual-list li::before {
            content: '‚Ä¢';
            color: #00d4ff;
            position: absolute;
            left: 0;
            top: 0;
            font-weight: bold;
        }

        .manual-badge {
            display: inline-flex;
            /* Changed from inline-block for better vertical alignment if needed, or keeping inline-block is fine too */
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin: 0 4px;
            /* Add margin on both sides */
            font-weight: bold;
            vertical-align: middle;
            /* Aligns badge with text */
            margin-bottom: 2px;
            /* Slight spacing */
        }

        .badge-voice {
            background: rgba(33, 150, 243, 0.2);
            color: #2196f3;
        }

        .badge-save {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .badge-sound {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
        }

        .close-manual-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: #aaa;
            font-size: 1.5rem;
            cursor: pointer;
        }

        /* Visual Heartbeat Animation */
        @keyframes pulse-ring {
            0% {
                transform: scale(0.8);
                box-shadow: 0 0 0 0 rgba(255, 82, 82, 0.7);
            }

            70% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(255, 82, 82, 0);
            }

            100% {
                transform: scale(0.8);
                box-shadow: 0 0 0 0 rgba(255, 82, 82, 0);
            }
        }

        .voice-visualization.talking {
            animation: pulse-ring 1.5s infinite;
            color: #ff5252;
            /* Change color when talking */
        }
    </style>
</head>

<body>
    <div class="container">
        <header style="position: relative;">
            <h1>üî¨ ÏïÑÏó∞ÎèÑÍ∏àÎëêÍªò Ï∏°Ï†ï ÌîÑÎ°úÍ∑∏Îû®</h1>
            <button class="manual-btn" onclick="openManual()">‚ùî</button>
        </header>

        <div class="material-section">
            <div class="material-header">
                <span class="material-header-title">üì¶ ÏûêÏû¨ ÏÑ†ÌÉù</span>
            </div>
            <div class="material-selector" id="materialSelector">
                <!-- Material buttons will be generated here -->
            </div>
        </div>

        <div class="sample-selector" id="sampleSelector">
            <!-- Sample buttons will be generated here -->
        </div>

        <div class="measurement-card">
            <div class="current-sample-header">
                <h2 id="currentSampleTitle">ÏûêÏû¨ 1 - ÏãúÎ£å #1</h2>
                <span class="progress-indicator" id="progressIndicator">0 / 20</span>
            </div>

            <div class="data-grid" id="dataGrid">
                <!-- Data inputs will be generated here -->
            </div>

            <div class="results-section">
                <h3 class="results-title">üìä Ï∏°Ï†ï Í≤∞Í≥º</h3>
                <div class="results-grid">
                    <div class="result-box min">
                        <div class="result-label">ÏµúÏÜüÍ∞í</div>
                        <div class="result-value" id="minValue">-</div>
                        <div class="result-unit">Œºm</div>
                    </div>
                    <div class="result-box avg">
                        <div class="result-label">ÌèâÍ∑†Í∞í</div>
                        <div class="result-value" id="avgValue">-</div>
                        <div class="result-unit">Œºm</div>
                    </div>
                </div>
            </div>

            <div class="action-buttons" style="flex-direction: column;">
                <button class="action-btn voice-btn" onclick="startVoiceInput()">üé§ ÏùåÏÑ±ÏúºÎ°ú ÏûÖÎ†•ÌïòÍ∏∞</button>
                <div style="display: flex; gap: 10px; width: 100%;">
                    <button class="action-btn clear" onclick="clearCurrentSample()">Ï¥àÍ∏∞Ìôî</button>
                    <button class="action-btn next" onclick="goToNextSample()">Îã§Ïùå ÏãúÎ£å ‚Üí</button>
                </div>
            </div>
        </div>

        <div class="summary-section">
            <h3 class="summary-title">üìã Ï†ÑÏ≤¥ ÏãúÎ£å ÏöîÏïΩ</h3>
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>ÏãúÎ£å</th>
                        <th>ÏµúÏÜüÍ∞í (Œºm)</th>
                        <th>ÌèâÍ∑†Í∞í (Œºm)</th>
                    </tr>
                </thead>
                <tbody id="summaryTableBody">
                    <!-- Summary rows will be generated here -->
                </tbody>
            </table>
            <button class="export-btn" onclick="exportData()">üì§ Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button>
        </div>
    </div>

    <script>
        const TOTAL_SAMPLES = 13;
        const MEASUREMENTS_PER_SAMPLE = 20;

        // Data storage - now supports multiple materials
        let materials = []; // Array of material objects, each containing allData
        let currentMaterial = 0;
        let currentSample = 0;

        // Get current material's data
        function getAllData() {
            return materials[currentMaterial].samples;
        }

        // Initialize data structure for a single material
        function createMaterialData(materialNumber) {
            const samples = [];
            for (let i = 0; i < TOTAL_SAMPLES; i++) {
                samples.push({
                    sampleNumber: i + 1,
                    measurements: new Array(MEASUREMENTS_PER_SAMPLE).fill(null),
                    min: null,
                    avg: null
                });
            }
            return {
                materialNumber: materialNumber,
                name: `ÏûêÏû¨ ${materialNumber}`,
                samples: samples
            };
        }

        // Initialize with one material
        function initializeData() {
            if (loadData()) {
                // If loaded successfully
            } else {
                materials = [createMaterialData(1)];
                currentMaterial = 0;
                currentSample = 0;
            }
        }

        // Save to LocalStorage
        function saveData() {
            const dataToSave = {
                materials: materials,
                state: {
                    currentMaterial: currentMaterial,
                    currentSample: currentSample
                }
            };
            try {
                localStorage.setItem('zincPlatingDataV2', JSON.stringify(dataToSave));
            } catch (e) {
                console.error("Save failed", e);
            }
        }

        // Load from LocalStorage
        function loadData() {
            const saved = localStorage.getItem('zincPlatingDataV2');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (parsed && parsed.materials) {
                        materials = parsed.materials;
                        // Restore state or default
                        if (parsed.state) {
                            currentMaterial = parsed.state.currentMaterial || 0;
                            currentSample = parsed.state.currentSample || 0;
                        } else {
                            currentMaterial = 0;
                            currentSample = 0;
                        }
                        return true;
                    }
                } catch (e) {
                    console.error("Load failed", e);
                }
            }
            return false;
        }

        // Add a new material
        function addMaterial() {
            const newMaterialNum = materials.length + 1;
            materials.push(createMaterialData(newMaterialNum));
            generateMaterialSelector();
            selectMaterial(materials.length - 1); // Switch to new material
            saveData();
        }

        // Select a material
        function selectMaterial(index) {
            currentMaterial = index;
            currentSample = 0;
            generateMaterialSelector();
            generateSampleSelector();
            generateDataGrid();
            updateResults();
            updateProgress();
            updateSummaryTable();
            updateCurrentTitle();
            saveData();
        }

        // Generate material selector buttons
        function generateMaterialSelector() {
            const selector = document.getElementById('materialSelector');
            selector.innerHTML = '';

            for (let i = 0; i < materials.length; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'material-btn-wrapper';

                const btn = document.createElement('button');
                btn.className = 'material-btn' + (i === currentMaterial ? ' active' : '');
                btn.textContent = materials[i].name;
                btn.onclick = () => selectMaterial(i);

                const editBtn = document.createElement('button');
                editBtn.className = 'edit-icon';
                editBtn.innerHTML = '‚úèÔ∏è';
                editBtn.title = 'Ïù¥Î¶Ñ Î≥ÄÍ≤Ω';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    renameMaterial(i);
                };

                wrapper.appendChild(btn);
                wrapper.appendChild(editBtn);
                selector.appendChild(wrapper);
            }

            // Add "ÏûêÏû¨ Ï∂îÍ∞Ä" button
            const addBtn = document.createElement('button');
            addBtn.className = 'add-material-btn';
            addBtn.textContent = '+ ÏûêÏû¨ Ï∂îÍ∞Ä';
            addBtn.onclick = addMaterial;
            selector.appendChild(addBtn);
        }

        // Rename material
        function renameMaterial(index) {
            const currentName = materials[index].name;
            const newName = prompt('ÏûêÏû¨ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:', currentName);

            if (newName && newName.trim() !== '') {
                materials[index].name = newName.trim();
                generateMaterialSelector();
                updateCurrentTitle();
                saveData();
            }
        }

        // Update current sample title
        function updateCurrentTitle() {
            document.getElementById('currentSampleTitle').textContent =
                `${materials[currentMaterial].name} - ÏãúÎ£å #${currentSample + 1}`;
        }

        // Generate sample selector buttons
        function generateSampleSelector() {
            const selector = document.getElementById('sampleSelector');
            selector.innerHTML = '';
            const allData = getAllData();

            for (let i = 0; i < TOTAL_SAMPLES; i++) {
                const btn = document.createElement('button');
                btn.className = 'sample-btn' + (i === currentSample ? ' active' : '');
                btn.textContent = i + 1;
                btn.onclick = () => selectSample(i);

                // Check if sample is completed
                if (allData[i] && allData[i].measurements.every(m => m !== null)) {
                    btn.classList.add('completed');
                }

                selector.appendChild(btn);
            }
        }

        // Generate data input grid
        function generateDataGrid() {
            const grid = document.getElementById('dataGrid');
            grid.innerHTML = '';
            const allData = getAllData();

            for (let i = 0; i < MEASUREMENTS_PER_SAMPLE; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'data-input-wrapper';

                const label = document.createElement('label');
                label.textContent = `#${i + 1}`;

                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'data-input';
                input.id = `input-${i}`;
                input.inputMode = 'decimal';
                input.step = '0.1';
                input.placeholder = '';

                // Set value if exists
                if (allData[currentSample] && allData[currentSample].measurements[i] !== null) {
                    input.value = allData[currentSample].measurements[i];
                    input.classList.add('filled');
                }

                // Event listeners
                input.addEventListener('input', (e) => handleInput(i, e.target.value));
                input.addEventListener('keydown', (e) => handleKeydown(i, e));
                input.addEventListener('focus', () => highlightCurrentInput(i));

                wrapper.appendChild(label);
                wrapper.appendChild(input);
                grid.appendChild(wrapper);
            }

            // Highlight first empty input
            highlightNextEmpty();
        }

        // Handle input change
        function handleInput(index, value) {
            const numValue = value === '' ? null : parseFloat(value);
            const allData = getAllData();
            allData[currentSample].measurements[index] = numValue;

            const input = document.getElementById(`input-${index}`);
            if (numValue !== null) {
                input.classList.add('filled');
            } else {
                input.classList.remove('filled');
            }

            updateResults();
            updateProgress();
            generateSampleSelector();
            saveData();
        }

        // Handle keydown events
        function handleKeydown(index, e) {
            if (e.key === 'Enter') {
                e.preventDefault();

                // Move to next input
                const nextIndex = index + 1;
                if (nextIndex < MEASUREMENTS_PER_SAMPLE) {
                    const nextInput = document.getElementById(`input-${nextIndex}`);
                    nextInput.focus();
                } else {
                    // All inputs filled, show completion
                    document.activeElement.blur();
                }
            }
        }

        // Highlight current input
        function highlightCurrentInput(index) {
            // Remove current class from all
            document.querySelectorAll('.data-input').forEach(input => {
                input.classList.remove('current');
            });

            // Add current class to focused input
            const input = document.getElementById(`input-${index}`);
            if (input) {
                input.classList.add('current');
            }
        }

        /* Manual Modal Logic */
        function openManual() {
            document.getElementById('manualModal').style.display = 'flex';
        }

        function closeManual() {
            document.getElementById('manualModal').style.display = 'none';
        }

        // Close modal if clicking outside
        window.onclick = function (event) {
            const voiceModal = document.getElementById('voiceModal');
            const manualModal = document.getElementById('manualModal');
            if (event.target == voiceModal) {
                // Do not close voice modal on outside click to prevent accidental stops
            }
            if (event.target == manualModal) {
                closeManual();
            }
        }

        // Find and highlight next empty input
        function highlightNextEmpty(skipFocus = false) {
            const allData = getAllData();
            for (let i = 0; i < MEASUREMENTS_PER_SAMPLE; i++) {
                if (allData[currentSample].measurements[i] === null) {
                    const input = document.getElementById(`input-${i}`);
                    if (input) {
                        input.classList.add('current');
                        if (!skipFocus) {
                            input.focus();
                        }
                    }
                    break;
                }
            }
        }

        // Update results display
        function updateResults() {
            const allData = getAllData();
            const measurements = allData[currentSample].measurements.filter(m => m !== null);

            if (measurements.length > 0) {
                const min = Math.min(...measurements);
                const avg = measurements.reduce((a, b) => a + b, 0) / measurements.length;

                allData[currentSample].min = min;
                allData[currentSample].avg = avg;

                document.getElementById('minValue').textContent = min.toFixed(1);
                document.getElementById('avgValue').textContent = avg.toFixed(1);
            } else {
                allData[currentSample].min = null;
                allData[currentSample].avg = null;

                document.getElementById('minValue').textContent = '-';
                document.getElementById('avgValue').textContent = '-';
            }

            updateSummaryTable();
        }

        // Update progress indicator
        function updateProgress() {
            const allData = getAllData();
            const filledCount = allData[currentSample].measurements.filter(m => m !== null).length;
            document.getElementById('progressIndicator').textContent = `${filledCount} / ${MEASUREMENTS_PER_SAMPLE}`;
        }

        // Select a sample
        function selectSample(index) {
            currentSample = index;
            updateCurrentTitle();

            generateSampleSelector();
            generateDataGrid();
            updateResults();
            updateProgress();
            saveData();
        }

        // Clear current sample data
        function clearCurrentSample() {
            if (confirm('ÌòÑÏû¨ ÏãúÎ£åÏùò Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                const allData = getAllData();
                allData[currentSample].measurements = new Array(MEASUREMENTS_PER_SAMPLE).fill(null);
                allData[currentSample].min = null;
                allData[currentSample].avg = null;

                generateDataGrid();
                updateResults();
                updateProgress();
                generateSampleSelector();
                saveData();
            }
        }

        // Go to next sample
        function goToNextSample() {
            // ÌòÑÏû¨ ÏãúÎ£åÏùò ÏûÖÎ†•Îêú Îç∞Ïù¥ÌÑ∞ Í∞úÏàò ÌôïÏù∏
            const allData = getAllData();
            const filledCount = allData[currentSample].measurements.filter(m => m !== null).length;

            // 20Í∞ú ÎØ∏ÎßåÏù∏ Í≤ΩÏö∞ Í≤ΩÍ≥† ÌåùÏóÖ
            if (filledCount < MEASUREMENTS_PER_SAMPLE) {
                const remaining = MEASUREMENTS_PER_SAMPLE - filledCount;
                if (!confirm(`‚ö†Ô∏è Îç∞Ïù¥ÌÑ∞Í∞Ä ${filledCount}/${MEASUREMENTS_PER_SAMPLE}Í∞úÎßå ÏûÖÎ†•ÎêòÏóàÏäµÎãàÎã§.\n\n${remaining}Í∞úÏùò Îç∞Ïù¥ÌÑ∞Í∞Ä Îçî ÌïÑÏöîÌï©ÎãàÎã§.\n\nÍ∑∏ÎûòÎèÑ Îã§Ïùå ÏãúÎ£åÎ°ú Ïù¥ÎèôÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                    return; // Ï∑®ÏÜå Ïãú ÌòÑÏû¨ ÏãúÎ£åÏóê Ïú†ÏßÄ
                }
            }

            if (currentSample < TOTAL_SAMPLES - 1) {
                selectSample(currentSample + 1);
            } else {
                alert('ÎßàÏßÄÎßâ ÏãúÎ£åÏûÖÎãàÎã§.');
            }
        }

        // Update summary table
        function updateSummaryTable() {
            const tbody = document.getElementById('summaryTableBody');
            tbody.innerHTML = '';
            const allData = getAllData();

            for (let i = 0; i < TOTAL_SAMPLES; i++) {
                const row = document.createElement('tr');

                const sampleCell = document.createElement('td');
                sampleCell.textContent = `#${i + 1}`;

                const minCell = document.createElement('td');
                minCell.textContent = allData[i].min !== null ? allData[i].min.toFixed(1) : '-';
                minCell.style.color = allData[i].min !== null ? '#ff5722' : '#888';

                const avgCell = document.createElement('td');
                avgCell.textContent = allData[i].avg !== null ? allData[i].avg.toFixed(1) : '-';
                avgCell.style.color = allData[i].avg !== null ? '#4caf50' : '#888';

                row.appendChild(sampleCell);
                row.appendChild(minCell);
                row.appendChild(avgCell);
                tbody.appendChild(row);
            }
        }

        // Export data
        function exportData() {
            const allData = getAllData();
            let csvContent = `${materials[currentMaterial].name}\n`;
            csvContent += 'ÏãúÎ£åÎ≤àÌò∏,';

            // Header row for measurements
            for (let i = 1; i <= MEASUREMENTS_PER_SAMPLE; i++) {
                csvContent += `Ï∏°Ï†ï${i},`;
            }
            csvContent += 'ÏµúÏÜüÍ∞í,ÌèâÍ∑†Í∞í\n';

            // Data rows
            for (let i = 0; i < TOTAL_SAMPLES; i++) {
                csvContent += `${i + 1},`;

                for (let j = 0; j < MEASUREMENTS_PER_SAMPLE; j++) {
                    csvContent += (allData[i].measurements[j] !== null ? allData[i].measurements[j] : '') + ',';
                }

                csvContent += (allData[i].min !== null ? allData[i].min.toFixed(1) : '') + ',';
                csvContent += (allData[i].avg !== null ? allData[i].avg.toFixed(1) : '') + '\n';
            }

            // Create and download file
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `ÏïÑÏó∞ÎèÑÍ∏àÎëêÍªòÏ∏°Ï†ï_${materials[currentMaterial].name}_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Voice Recognition Functionality
        let recognition = null;
        let shouldBeListening = false; // Explicit user intent flag
        let isEngineRunning = false; // Actual engine state tracking
        let watchdogTimer = null;
        let silenceTimer = null;

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            function createRecognition() {
                const r = new SpeechRecognition();
                r.continuous = true;
                r.interimResults = true;
                r.lang = 'ko-KR';

                r.onstart = () => {
                    console.log('Voice recognition started (onstart)');
                    isEngineRunning = true;
                    document.getElementById('voiceModal').style.display = 'flex';
                    document.getElementById('voiceStatus').textContent = "Îì£Í≥† ÏûàÏäµÎãàÎã§... Ïà´ÏûêÎ•º ÎßêÌï¥Ï£ºÏÑ∏Ïöî.";
                    updateVisualState(true);
                };

                r.onend = () => {
                    console.log('Voice recognition ended (onend)');
                    isEngineRunning = false;
                    updateVisualState(false);

                    // Auto-restart if user intended to keep listening
                    if (shouldBeListening) {
                        document.getElementById('voiceStatus').textContent = "Ïó∞Í≤∞ Ïû¨ÏãúÎèÑ Ï§ë...";
                        // Let the watchdog handle the restart to avoid tight loop conflicts
                    } else {
                        document.getElementById('voiceModal').style.display = 'none';
                    }
                };

                r.onresult = (event) => {
                    // Reset silence timer on any result
                    resetSilenceDetection();

                    let interimTranscript = '';
                    let finalTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }

                    if (interimTranscript) {
                        document.getElementById('voiceResult').textContent = interimTranscript + '...';
                        document.getElementById('voiceResult').style.color = '#aaa';
                    }
                    if (finalTranscript) {
                        document.getElementById('voiceResult').textContent = finalTranscript;
                        document.getElementById('voiceResult').style.color = '#00d4ff';
                        processVoiceInput(finalTranscript);
                    }
                };

                r.onerror = (event) => {
                    console.error('Voice error', event.error);
                    isEngineRunning = false; // Assume dead on error

                    if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        shouldBeListening = false;
                        document.getElementById('voiceStatus').textContent = "ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§.";
                        alert("ÎßàÏù¥ÌÅ¨ ÏÇ¨Ïö© Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.");
                    } else if (event.error === 'no-speech') {
                        // Ignore no-speech, let watchdog restart
                    } else {
                        // For other errors, we might want to recreate the instance
                        // But for now let watchdog handle restart
                    }
                };

                // Visual Heartbeat Trigger (Chrome only)
                if ('onsoundstart' in r) {
                    r.onsoundstart = () => {
                        document.querySelector('.voice-visualization').classList.add('talking');
                    };
                    r.onsoundend = () => {
                        document.querySelector('.voice-visualization').classList.remove('talking');
                    };
                }

                return r;
            }

            // Watchdog: The key definition for fixing "zombie" state
            // Checks every 1s if we should be listening but engine is dead
            function startWatchdog() {
                if (watchdogTimer) clearInterval(watchdogTimer);
                watchdogTimer = setInterval(() => {
                    if (shouldBeListening && !isEngineRunning) {
                        console.warn('Watchdog: Engine dead while listening. Force restarting...');
                        restartEngine();
                    }
                }, 1000);
            }

            function stopWatchdog() {
                if (watchdogTimer) clearInterval(watchdogTimer);
                watchdogTimer = null;
            }

            function resetSilenceDetection() {
                if (silenceTimer) clearTimeout(silenceTimer);
                silenceTimer = setTimeout(() => {
                    // Optional: If no speech for 10s, maybe trigger something?
                    // For now, we trust continuous mode, but sometimes it just stops.
                    // Watchdog handles the stop.
                }, 10000);
            }

            function restartEngine() {
                try {
                    if (recognition) recognition.abort();
                } catch (e) { }

                // Re-create instance to clear any internal frozen state
                recognition = createRecognition();
                try {
                    recognition.start();
                } catch (e) { console.log("Restart fail:", e); }
            }

            // Initial creation
            recognition = createRecognition();

        } else {
            alert("Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî ÏùåÏÑ± Ïù∏ÏãùÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§. ChromeÏùÑ ÏÇ¨Ïö©Ìï¥Ï£ºÏÑ∏Ïöî.");
        }

        function updateVisualState(listening) {
            const vis = document.querySelector('.voice-visualization');
            if (listening) {
                vis.style.opacity = '1';
                vis.textContent = 'üé§';
            } else {
                vis.style.opacity = '0.5';
                vis.classList.remove('talking');
                vis.textContent = 'üí§';
            }
        }

        // Sound Feedback (Previously added, keeping same)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            // ... existing playSound logic (no changes needed) ...
            // Re-declaring for completeness if replaced block covers it
            // But assume we keep the helper function block above unmodified.
            // Wait, I am replacing the block including 'startVoiceInput', so I should be careful not to delete helpers.
            // The replace range is 1162 ~ 1460.
            // Helpers are ABOVE startVoiceInput in previous content? 
            // Let's check line numbers. helper 'playSound' is around 1244. 
            // Logic 'processVoiceInput' is around 1384. They are inside the range I am replacing?
            // YES. I need to include them or exclude them from replacement.
            // Best to include them to be safe or adjust range.
            // 'processVoiceInput', 'undoLastInput', 'playSound', 'parseKoreanNumbers' seem to be INSIDE the replaced block in my previous view?
            // I will include references to them but I should confirm if I need to re-write implementation.
            // Actually, 'playSound' was at 1244. 'startVoiceInput' is at 1423.
            // I will try to preserve helpers by NARROWING the replacement range.
            // Replacing 1161 (let recognition...) down to before 'playSound' (1240s) might be safer for INIT logic.
            // Then startVoiceInput (1420s) separately.
            // BUT I need to change `createRecognition` which is at the top.
            // And I need `shouldBeListening` global variable.
            // So I will replace the top block, and leave helpers alone?
            // No, the helpers use `recognition` variable?
            // `recognition` is global `let recognition = null`.

            // Strategy: Retain helpers, just replace the recognition Setup and start/stop functions.

            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'input') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'undo') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(220, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.2);
            }
        }

        // Undo functionality for Voice Command
        function undoLastInput() {
            let currentInput = document.querySelector('.data-input.current');
            let targetIndex = -1;

            if (currentInput) {
                const currentIndex = parseInt(currentInput.id.split('-')[1]);
                if (currentIndex > 0) {
                    targetIndex = currentIndex - 1;
                } else {
                    document.getElementById('voiceStatus').textContent = "Ï≤´ Î≤àÏß∏ Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§.";
                    return;
                }
            } else {
                const allData = getAllData();
                const measurements = allData[currentSample].measurements;
                for (let i = MEASUREMENTS_PER_SAMPLE - 1; i >= 0; i--) {
                    if (measurements[i] !== null) {
                        targetIndex = i;
                        break;
                    }
                }
            }

            if (targetIndex !== -1) {
                const allData = getAllData();
                allData[currentSample].measurements[targetIndex] = null;

                const input = document.getElementById(`input-${targetIndex}`);
                input.value = '';
                input.classList.remove('filled');

                handleInput(targetIndex, '');

                highlightCurrentInput(targetIndex);
                if (document.getElementById('voiceModal').style.display !== 'flex') {
                    input.focus();
                }

                document.getElementById('voiceStatus').textContent = `${targetIndex + 1}Î≤àÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú ÎßêÏîÄÌï¥Ï£ºÏÑ∏Ïöî.`;
                playSound('undo');
                console.log('Undone index:', targetIndex);
            }
        }

        // Helper to Convert Korean text numbers directly to digits
        function parseKoreanNumbers(text) {
            let processed = text.replace(/\s+/g, '');

            const specialHundreds = {
                'Î∞±Ïã≠': '110', 'Î∞±Ïó¥': '110',
                'Î∞±Íµ¨': '109', 'Î∞±ÏïÑÌôâ': '109', 'ÏùºÍ≥µÍµ¨': '109',
                'Î∞±Ìåî': '108', 'Î∞±Ïó¨Îçü': '108', 'ÏùºÍ≥µÌåî': '108',
                'Î∞±Ïπ†': '107', 'Î∞±ÏùºÍ≥±': '107', 'ÏùºÍ≥µÏπ†': '107',
                'Î∞±Ïú°': '106', 'Î∞±Ïó¨ÏÑØ': '106', 'ÏùºÍ≥µÏú°': '106',
                'Î∞±Ïò§': '105', 'Î∞±Îã§ÏÑØ': '105', 'ÏùºÍ≥µÏò§': '105',
                'Î∞±ÏÇ¨': '104', 'Î∞±ÎÑ∑': '104', 'ÏùºÍ≥µÏÇ¨': '104',
                'Î∞±ÏÇº': '103', 'Î∞±ÏÖã': '103', 'ÏùºÍ≥µÏÇº': '103',
                'Î∞±Ïù¥': '102', 'Î∞±Îëò': '102', 'ÏùºÍ≥µÏù¥': '102',
                'Î∞±Ïùº': '101', 'Î∞±ÌïòÎÇò': '101', 'ÏùºÍ≥µÏùº': '101',
                'Î∞±ÏòÅ': '100', 'Î∞±Í≥µ': '100', 'ÏùºÍ≥µÍ≥µ': '100',
                'Î∞±': '100'
            };

            for (const [key, val] of Object.entries(specialHundreds)) {
                if (processed.includes(key)) {
                    processed = processed.split(key).join(val);
                }
            }

            const digits = {
                'ÏòÅ': '0', 'Í≥µ': '0',
                'Ïùº': '1', 'ÌïòÎÇò': '1',
                'Ïù¥': '2', 'Îëò': '2',
                'ÏÇº': '3', 'ÏÖã': '3',
                'ÏÇ¨': '4', 'ÎÑ∑': '4',
                'Ïò§': '5', 'Îã§ÏÑØ': '5',
                'Ïú°': '6', 'Ïó¨ÏÑØ': '6',
                'Ïπ†': '7', 'ÏùºÍ≥±': '7',
                'Ìåî': '8', 'Ïó¨Îçü': '8',
                'Íµ¨': '9', 'ÏïÑÌôâ': '9',
                'Ïã≠': '10', 'Ïó¥': '10'
            };

            for (const [key, val] of Object.entries(digits)) {
                if (processed.includes(key)) {
                    processed = processed.split(key).join(val);
                }
            }

            if (processed.includes('Ï≤ú')) processed = processed.replace(/Ï≤ú/g, '1000');

            return processed;
        }

        let lastProcessedTranscript = '';
        let lastProcessedTime = 0;

        function processVoiceInput(transcript) {
            const cleanText = transcript.trim();
            const now = Date.now();

            if (cleanText === lastProcessedTranscript && (now - lastProcessedTime < 1000)) {
                return;
            }

            lastProcessedTranscript = cleanText;
            lastProcessedTime = now;

            if (cleanText.includes('Ï¢ÖÎ£å') || cleanText.includes('Í∑∏Îßå') || cleanText.includes('Îã´Í∏∞')) {
                stopVoiceInput();
                return;
            }

            if (cleanText.includes('Îã§Ïãú') || cleanText.includes('Ï∑®ÏÜå') || cleanText.includes('Îí§Î°ú')) {
                undoLastInput();
                return;
            }

            let processedText = cleanText;
            processedText = parseKoreanNumbers(processedText);
            processedText = processedText.replace(/Ï†ê/g, '.');
            processedText = processedText.replace(/,/g, '');

            const regex = /[\d]+(\.[\d]+)?/g;
            const matches = processedText.match(regex);

            if (matches) {
                matches.forEach(numberStr => {
                    const numValue = parseFloat(numberStr);
                    if (!isNaN(numValue)) {
                        inputNumber(numValue);
                    }
                });
            }
        }

        function startVoiceInput() {
            if (!recognition) {
                alert("Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî ÏùåÏÑ± Ïù∏ÏãùÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
                return;
            }

            // check https
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                alert('ÏùåÏÑ± Ïù∏Ïãù Í∏∞Îä•ÏùÄ Î≥¥Ïïà Î¨∏Ï†úÎ°ú HTTPS ÎòêÎäî localhost ÌôòÍ≤ΩÏóêÏÑúÎßå ÏûëÎèôÌï©ÎãàÎã§.');
                return;
            }

            shouldBeListening = true;
            highlightNextEmpty(true);

            startWatchdog(); // Activate watchdog

            // Force restart if already running or in unknown state
            try {
                if (recognition) recognition.abort();
            } catch (e) { }

            setTimeout(() => {
                if (shouldBeListening) {
                    try {
                        recognition.start();
                    } catch (e) {
                        console.log("Start error:", e);
                    }
                }
            }, 100);
        }

        function stopVoiceInput() {
            shouldBeListening = false;
            stopWatchdog(); // Kill watchdog

            if (recognition) {
                try {
                    recognition.abort(); // abort() is better than stop() for immediate cleanup
                } catch (e) { }
            }
            document.getElementById('voiceModal').style.display = 'none';
        }

        function inputNumber(number) {
            let targetInput = document.querySelector('.data-input.current');

            if (!targetInput) {
                const allData = getAllData();
                for (let i = 0; i < MEASUREMENTS_PER_SAMPLE; i++) {
                    if (allData[currentSample].measurements[i] === null) {
                        targetInput = document.getElementById(`input-${i}`);
                        break;
                    }
                }
            }

            if (targetInput) {
                targetInput.value = number;
                const index = parseInt(targetInput.id.split('-')[1]);
                handleInput(index, number); // Logic from existing code

                // Move to next
                const nextIndex = index + 1;
                if (nextIndex < MEASUREMENTS_PER_SAMPLE) {
                    highlightCurrentInput(nextIndex);
                    const nextInput = document.getElementById(`input-${nextIndex}`);

                    // Only focus if Voice Modal is NOT open (prevents keyboard popup)
                    if (nextInput && document.getElementById('voiceModal').style.display !== 'flex') {
                        nextInput.focus();
                    }
                } else {
                    // Sample full
                    document.getElementById('voiceStatus').textContent = "ÌòÑÏû¨ ÏãúÎ£å ÏûÖÎ†• ÏôÑÎ£å! 'Îã§Ïùå'Ïù¥ÎùºÍ≥† ÎßêÌïòÍ±∞ÎÇò Î≤ÑÌäºÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.";
                }

                playSound('input');
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeData();
            generateMaterialSelector();
            generateSampleSelector();
            generateDataGrid();
            updateSummaryTable();
        });
    </script>

    <!-- Manual Modal -->
    <div id="manualModal" class="voice-modal" style="display: none; justify-content: center; align-items: center;">
        <div class="manual-modal-content">
            <button class="close-manual-btn" onclick="closeManual()">√ó</button>
            <h3 class="manual-title">üìñ ÏÇ¨Ïö© Îß§Îâ¥Ïñº</h3>

            <div class="manual-section">
                <h4>1. ÏûêÏû¨Ï∂îÍ∞Ä</h4>
                <ul class="manual-list">
                    <li>ÏûêÏû¨ ÏÑ†ÌÉù ÏòÅÏó≠ Ïö∞Ï∏°Ïùò <span class="manual-badge" style="border: 1px dashed #aaa; color: #aaa;">+ ÏûêÏû¨
                            Ï∂îÍ∞Ä</span> Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Î©¥ ÏÉàÎ°úÏö¥ ÏûêÏû¨ ÌÉ≠Ïù¥ ÏÉùÏÑ±Îê©ÎãàÎã§.</li>
                </ul>
            </div>

            <div class="manual-section">
                <h4>2. ÏûêÏû¨Î™Ö Î≥ÄÍ≤ΩÎ∞©Î≤ï</h4>
                <ul class="manual-list">
                    <li>ÏûêÏû¨ Ïù¥Î¶Ñ ÏòÜÏùò <span class="manual-badge" style="background: rgba(255, 255, 255, 0.1);">‚úèÔ∏è</span> ÏïÑÏù¥ÏΩòÏùÑ
                        ÌÅ¥Î¶≠ÌïòÎ©¥ ÏûêÏû¨ Ïù¥Î¶ÑÏùÑ Î≥ÄÍ≤ΩÌï† Ïàò ÏûàÏäµÎãàÎã§.</li>
                </ul>
            </div>

            <div class="manual-section">
                <h4>3. ÏùåÏÑ±Ïù∏Ïãù Î∞©Î≤ï</h4>
                <ul class="manual-list">
                    <li><span class="manual-badge badge-voice">ÏãúÏûë</span> [ÏùåÏÑ±ÏúºÎ°ú ÏûÖÎ†•ÌïòÍ∏∞] Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Í≥† ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏùÑ ÌóàÏö©ÌïòÏÑ∏Ïöî.</li>
                    <li><span class="manual-badge badge-voice">ÏûÖÎ†•</span> Ïà´ÏûêÎ•º ÎßêÌïòÎ©¥ ÏûêÎèôÏúºÎ°ú ÏûÖÎ†•Îê©ÎãàÎã§. (Ïòà: "12.5")</li>
                    <li><span class="manual-badge badge-voice">Îã§Ïãú</span> Ïà´ÏûêÎ•º ÏûòÎ™ª ÏûÖÎ†•ÌñàÏùÑ Îïå <strong>"Îã§Ïãú"</strong>ÎùºÍ≥† ÎßêÌïòÎ©¥ Î∞©Í∏à
                        ÏûÖÎ†•Ìïú Í∞íÏù¥ Ï∑®ÏÜåÎê©ÎãàÎã§.</li>
                </ul>
            </div>

            <div class="manual-section">
                <h4>4. ÏûêÎèôÏ†ÄÏû•Í∏∞Îä•</h4>
                <ul class="manual-list">
                    <li><span class="manual-badge badge-save">ÏûêÎèôÏ†ÄÏû•</span> Î™®Îì† Îç∞Ïù¥ÌÑ∞Îäî ÏûÖÎ†• Ï¶âÏãú Î∏åÎùºÏö∞Ï†ÄÏóê ÏûêÎèô Ï†ÄÏû•ÎêòÏñ¥, Ïï±ÏùÑ Ï¢ÖÎ£åÌï¥ÎèÑ Îç∞Ïù¥ÌÑ∞Í∞Ä
                        Ïú†ÏßÄÎê©ÎãàÎã§.</li>
                </ul>
            </div>

            <div class="manual-section">
                <h4>5. Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Í∏∞Îä•</h4>
                <ul class="manual-list">
                    <li>ÌôîÎ©¥ ÌïòÎã®Ïùò <span class="manual-badge"
                            style="background: linear-gradient(135deg, #9c27b0, #e91e63);">üì§ Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞</span> Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Î©¥ ÌòÑÏû¨
                        ÏûêÏû¨Ïùò Ï∏°Ï†ï Îç∞Ïù¥ÌÑ∞Î•º ÏóëÏÖÄ(CSV) ÌååÏùºÎ°ú Ï†ÄÏû•Ìï† Ïàò ÏûàÏäµÎãàÎã§.</li>
                </ul>
            </div>

            <button class="action-btn next" onclick="closeManual()"
                style="width: 100%; margin-top: 10px;">ÌôïÏù∏ÌñàÏäµÎãàÎã§</button>
        </div>
    </div>

    <!-- Voice Interface Modal -->
    <div id="voiceModal" class="voice-modal">
        <div class="voice-visualization">üé§</div>
        <div id="voiceStatus" class="voice-status-text">Îì£Í≥† ÏûàÏäµÎãàÎã§...</div>
        <div id="voiceResult" class="voice-result-text">-</div>
        <button class="close-voice-btn" onclick="stopVoiceInput()">Îã´Í∏∞ (Ï¢ÖÎ£å)</button>
    </div>
</body>

</html>
